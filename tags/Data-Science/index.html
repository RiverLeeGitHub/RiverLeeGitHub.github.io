<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Tag: Data Science - Hexo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/tags/Data-Science/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">





<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Hexo" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="http://github.com/riverleegithub">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Pencarian" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">Tag</a></li>
            <li class="is-active"><a href="#" aria-current="page">Data Science</a></li>
        </ul>
        </nav>
    </div>
</div>

    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-01T07:26:14.000Z">2019-03-01</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    8 minutes membaca (Sekitar 1257 kata)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/01/MapReduce和YARN的区别和联系-转/">MapReduce和YARN的区别和联系[转]</a>
            
        </h1>
        <div class="content">
            <p>初学Hadoop，多多学习 :)</p>
<p>本文转载自<a href="https://blog.csdn.net/hahachenchen789/article/details/80489506" target="_blank" rel="noopener">MapReduce和YARN的区别和联系</a></p>
<p>Hadoop 的最常见用法之一是 Web 搜索。虽然它不是唯一的软件框架应用程序，但作为一个并行数据处理引擎，它的表现非常突出。Hadoop 最有趣的方面之一是 Map and Reduce 流程，它受到Google开发的启发。这个流程称为创建索引，它将 Web爬行器检索到的文本 Web 页面作为输入，并且将这些页面上的单词的频率报告作为结果。然后可以在整个 Web 搜索过程中使用这个结果从已定义的搜索参数中识别内容。</p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>最简单的 MapReduce应用程序至少包含 3 个部分：一个 Map 函数、一个 Reduce 函数和一个 main 函数。main 函数将作业控制和文件输入/输出结合起来。在这点上，Hadoop 提供了大量的接口和抽象类，从而为 Hadoop应用程序开发人员提供许多工具，可用于调试和性能度量等。</p>
<p>MapReduce 本身就是用于并行处理大数据集的软件框架。MapReduce 的根源是函数性编程中的 map 和 reduce 函数。它由两个可能包含有许多实例（许多 Map 和 Reduce）的操作组成。Map 函数接受一组数据并将其转换为一个键/值对列表，输入域中的每个元素对应一个键/值对。Reduce 函数接受 Map 函数生成的列表，然后根据它们的键（为每个键生成一个键/值对）缩小键/值对列表。</p>
<p>这里提供一个示例，帮助您理解它。假设输入域是 one small step for man,one giant leap for mankind。在这个域上运行 Map 函数将得出以下的键/值对列表：</p>
<p>（one,1） (small,1） (step,1） (for,1） (man,1） (one,1） (giant,1） (leap,1） (for,1） (mankind,1）</p>
<p>如果对这个键/值对列表应用 Reduce 函数，将得到以下一组键/值对：</p>
<p>（one,2） (small,1） (step,1） (for,2） (man,1）（giant,1） (leap,1） (mankind,1）</p>
<p>结果是对输入域中的单词进行计数，这无疑对处理索引十分有用。但是，假设有两个输入域，第一个是 one small step for man，第二个是 one giant leap for mankind。您可以在每个域上执行 Map 函数和 Reduce 函数，然后将这两个键/值对列表应用到另一个 Reduce 函数，这时得到与前面一样的结果。换句话说，可以在输入域并行使用相同的操作，得到的结果是一样的，但速度更快。这便是 MapReduce 的威力；它的并行功能可在任意数量的系统上使用。</p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>它是如何实现这个功能的？一个代表客户机在单个主系统上启动的 MapReduce应用程序称为 JobTracker。类似于 NameNode，它是 Hadoop 集群中惟一负责控制 MapReduce应用程序的系统。在应用程序提交之后，将提供包含在 HDFS 中的输入和输出目录。JobTracker 使用文件块信息（物理量和位置）确定如何创建其他 TaskTracker 从属任务。MapReduce应用程序被复制到每个出现输入文件块的节点。将为特定节点上的每个文件块创建一个惟一的从属任务。每个 TaskTracker 将状态和完成信息报告给 JobTracker。</p>
<p>Hadoop 的这个特点非常重要，因为它并没有将存储移动到某个位置以供处理，而是将处理移动到存储。这通过根据集群中的节点数调节处理，因此支持高效的数据处理。</p>
<p>Hadoop是一种分布式数据和计算的框架。它很擅长存储大量的半结构化的数据集。数据可以随机存放，所以一个磁盘的失败并不会带来数据丢失。Hadoop也非常擅长分布式计算——快速地跨多台机器处理大型数据集合。</p>
<p>MapReduce是处理大量半结构化数据集合的编程模型。编程模型是一种处理并结构化特定问题的方式。例如，在一个关系数据库中，使用一种集合语言执行查询，如SQL。告诉语言想要的结果，并将它提交给系统来计算出如何产生计算。还可以用更传统的语言(C++，Java)，一步步地来解决问题。这是两种不同的编程模型，MapReduce就是另外一种。</p>
<p>MapReduce和Hadoop是相互独立的，实际上又能相互配合工作得很好。</p>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-02-20T09:22:21.000Z">2019-02-20</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 hours membaca (Sekitar 16540 kata)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/02/20/Pig的一些基础概念及用法总结-转/">Pig的一些基础概念及用法总结[转]</a>
            
        </h1>
        <div class="content">
            <p>本文转载自<a href="https://www.codelast.com/%E5%8E%9F%E5%88%9Bpig%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/" target="_blank">Apache Pig的一些基础概念及用法总结</a></p>
<p><div id="main" class="clearfix"></div></p>
<p><div class="inner-wrap"></div></p>
<p><div id="primary"></div></p>
<p><div id="content" class="clearfix"></div></p>
<p><article id="post-3621" class="post-3621 post type-post status-publish format-standard hentry category-linux category-original tag-apache-pig tag-cannot-find-hadoop-configurations-in-classpath tag-could-not-infer-the-matching-function-for-org-apache-pig-builtin-concat tag-could-not-instantiate-com-twitter-elephantbird-pig-load-hbaseloader tag-error-in-new-logical-plan tag-getschema tag-incompatible-types-in-equalto-operator-left-hand-side tag-inner-bag tag-inner-foreach tag-inner-join tag-join tag-load-function tag-localhost127-0-0-19000-already-tried tag-nested-foreach tag-org-apache-hadoop-ipc-client-retrying-connect-to-server tag-outer-join tag-pig-tutorial-in-chinese tag-pigstorage tag-pig tag-pighbase tag-scalars-can-be-only-used-with-projections tag-try-dpig-usenewlogicalplanfalse tag-udf tag-user-defined-function tag-35 tag-1029 tag-1043 tag-foreach tag-938 tag-1031 tag-792 tag-1087 tag-1085"></article></p>
<div class="entry-content clearfix">

<p></p><p>本文可以让刚接触pig的人对一些基础概念有个初步的了解。<br><br>本文大概是互联网上第一篇公开发表的且涵盖大量实际例子的Apache Pig中文教程（由Google搜索可知），文中的大量实例都是作者Darran Zhang（website: codelast.com）在工作、学习中总结的经验或解决的问题，并且添加了较为详尽的说明及注解，此外，作者还在不断地添加本文的内容，希望能帮助一部分人。</p><p></p>
<p></p><p><a href="http://pig.apache.org/" target="_blank">Apache pig</a>是用来处理大规模数据的高级查询语言，配合Hadoop使用，可以在处理海量数据时达到事半功倍的效果，比使用Java，C++等语言编写大规模数据处理程序的难度要小N倍，实现同样的效果的代码量也小N倍。Twitter就大量使用pig来处理海量数据&mdash;&mdash;有兴趣的，可以看Twitter工程师写的<a href="http://www.slideshare.net/kevinweil/hadoop-pig-and-twitter-nosql-east-2009" target="_blank">这个PPT</a>。<br><br>但是，刚接触pig时，可能会觉得里面的某些概念以及程序实现方法与想像中的很不一样，甚至有些莫名，所以，你需要仔细地研究一下基础概念，这样在写pig程序的时候，才不会觉得非常别扭。<br><br><span id="more-3621"></span><br><br>本文基于以下环境：<br><br>pig 0.8.1</p><p></p>
<p></p><p>先给出两个链接：<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref1.html" target="_blank">pig参考手册1</a>，<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html" target="_blank">pig参考手册2</a>。本文的部分内容来自这两个手册，但涉及到翻译的部分，也是我自己翻译的，因此可能理解与英文有偏差，如果你觉得有疑义，可参考英文内容。</p><p></p>
<p></p><p><span style="background-color:#ffccff;">【配置Pig语法高亮】</span><br><br>在正式开始学习Pig之前，你首先要明白，配置好编辑器的Pig语法高亮是很有用的，它可以极大地提高你的工作效率。</p><p></p>
<p><div><br>如果你在Windows下编写Pig代码，好像还真没有什么轻量级的编辑器插件（例如Notepad++的插件之类的）可以实现对.pig文件的语法高亮显示，我建议你使用Notepad++，在&ldquo;User Define Language&rdquo;中自定义Pig语法高亮方案（我这样做之后感觉效果很好）；如果你觉得麻烦，那么你可以直接用Notepad++以SQL的语法高亮来查看Pig代码，这样的话可以高亮Pig中的一部分关键字。<br><br>在Linux下，选择就很多了，大分部人使用的是vi，vim，但我是个Emacs控，所以我就先说说如何配置<span style="color: rgb(255, 0, 0); ">Emacs</span>的Pig语法高亮。此插件是一个很好的选择：<a href="https://github.com/cloudera/piglatin-mode" target="_blank">https://github.com/cloudera/piglatin-mode</a></div></p>
<p><div><br>那么，怎么使用这个插件呢？</div></p>
<p><div><br>下载piglatin.el文件，将它放置在任何地方&mdash;&mdash;当然，为了方便，最好是放在你登录用户的根目录下（也就是与.emacs配置文件在同一目录下），然后将其重命名为 &ldquo;<span style="color:#0000ff;">.piglatin.el</span>&rdquo;注意前面是有一个点的，也就是说将这个文件设置成隐藏文件，否则可能会误删了。然后，在 <span style="color:#0000ff;">.emacs</span> 文件中的最后，添加上如下一行：</div></p>
<p><div><br><span style="color:#0000ff;">(load-file &quot;/home/abc/.piglatin.el&quot;)</span></div></p>
<p><div><br>这里假设了你的 .piglatin.el 文件放置的位置是在 /home/abc/ 目录下，也就是说emacs会加载这个文件，实现语法高亮显示。</div></p>
<p><div><br>现在，你再打开一个.pig文件试试看？非常令人赏心悦目的高亮效果就出来了。效果如下图所示：</div></p>
<p><div style="text-align: center; "><br><img alt="" src="http://www.codelast.com/wp-content/uploads/2011/12/pig_syntax_highlight_emacs.png" style="width: 378px; height: 164px; "></div></p>
<p></p><p>其实Emacs也有Windows版的，如果你习惯在Windows下工作，完全可以在Windows下按上面的方法配置一下Pig语法高亮（但是Windows版的Emacs还需要一些额外的配置工作，例如修改注册表等，所以会比在Linux下使用要麻烦一些，具体请看<a href="http://www.codelast.com/?p=4802" target="_blank"><span style="color:#800080;">这篇文章</span></a>）。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>下面开始学习Pig。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（1）</span>关系（relation）、包（bag）、元组（tuple）、字段（field）、数据（data）的关系</p><p></p>
<p><ul></ul></p>
<p><li><br>一个关系（relation）是一个包（bag），更具体地说，是一个外部的包（outer bag）。</li></p>
<p><li><br>一个包（bag）是一个元组（tuple）的集合。<span style="color:#0000cd;">在pig中表示数据时，用大括号{}括起来的东西表示一个包&mdash;&mdash;无论是在教程中的实例演示，还是在pig交互模式下的输出，都遵循这样的约定，请牢记这一点，因为不理解的话就会对数据结构的掌握产生偏差</span>。</li></p>
<p><li><br>一个元组（tuple）是若干字段（field）的一个有序集（ordered set）。<span style="color:#0000cd;">在pig中表示数据时，用小括号()括起来的东西表示一个元组</span>。</li></p>
<p><li><br>一个字段是一块数据（data）。</li><br></p>
<p></p><p>&ldquo;元组&rdquo;这个词很抽象，你可以把它想像成关系型数据库表中的一行，它含有一个或多个字段，其中，每一个字段可以是任何数据类型，并且可以有或者没有数据。<br><br>&ldquo;关系&rdquo;可以比喻成关系型数据库的一张表，而上面说了，&ldquo;元组&rdquo;可以比喻成数据表中的一行，那么这里有人要问了，在关系型数据库中，同一张表中的每一行都有固定的字段数，pig中的&ldquo;关系&rdquo;与&ldquo;元组&rdquo;之间，是否也是这样的情况呢？不是的。&ldquo;关系&rdquo;并不要求每一个&ldquo;元组&rdquo;都含有相同数量的字段，并且也不会要求各&ldquo;元组&rdquo;中在相同位置处的字段具有相同的数据类型（太随意了，是吧？）<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（2）</span>一个 计算多维度组合下的平均值 的实际例子<br><br>为了帮助大家理解pig的一个基本的数据处理流程，我造了一些简单的数据来举个例子&mdash;&mdash;<br><br>假设有数据文件：a.txt（各数值之间是以tab分隔的）：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>a    1    2    3    4.2    9.8<br>a    3    0    5    3.5    2.1<br>b    7    9    9    -    -<br>a    7    9    9    2.6    6.2<br>a    1    2    5    7.7    5.9<br>a    1    2    3    1.4    0.2<br></pre></p>
<p></p><p>问题如下：怎样求出在第2、3、4列的所有组合的情况下，最后两列的平均值分别是多少？<br><br>例如，第2、3、4列有一个组合为（1，2，3），即第一行和最后一行数据。对这个维度组合来说，最后两列的平均值分别为：<br><br>（4.2+1.4）/2＝2.8<br><br>（9.8+0.2）/2＝5.0<br><br>而对于第2、3、4列的其他所有维度组合，都分别只有一行数据，因此最后两列的平均值其实就是它们自身。<br><br>特别地，组合（7，9，9）有两行记录：第三、四行，但是第三行数据的最后两列没有值，因此它不应该被用于平均值的计算，也就是说，在计算平均值时，第三行是无效数据。所以（7，9，9）组合的最后两列的平均值为 2.6 和 6.2。<br><br>我们现在用pig来算一下，并且输出最终的结果。<br><br>先进入本地调试模式（pig -x local），再依次输入如下pig代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>B = GROUP A BY (col2, col3, col4);<br>C = FOREACH B GENERATE group, AVG(A.col5), AVG(A.col6);<br>DUMP C;<br></pre></p>
<p></p><p>pig输出结果如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>((1,2,3),2.8,5.0)<br>((1,2,5),7.7,5.9)<br>((3,0,5),3.5,2.1)<br>((7,9,9),2.6,6.2)<br></pre></p>
<p></p><p>这个结果对吗？手工算一下就知道是对的。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>下面，我们依次来看看每一句pig代码分别得到了什么样的数据。<br><br><strong><span style="color:#ff0000;">①</span></strong>加载 a.txt 文件，并指定每一列的数据类型分别为 chararray（字符串），int，int，int，double，double。同时，我们还给予了每一列别名，分别为 col1，col2，&hellip;&hellip;，col6。这个别名在后面的数据处理中会用到&mdash;&mdash;如果你不指定别名，那么在后面的处理中，就只能使用索引（$0，$1，&hellip;&hellip;）来标识相应的列了，这样可读性会变差，因此，在列固定的情况下，还是指定别名的好。<br><br>将数据加载之后，保存到变量A中，A的数据结构如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}<br></pre></p>
<p></p><p>可见，A是用大括号括起来的东西。根据本文前面的说法，A是一个包（bag）。<br><br>这个时候，A与你想像中的样子应该是一致的，也就是与前面打印出来的 a.txt 文件的内容是一样的，还是一行一行的类似于&ldquo;二维表&rdquo;的数据。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><strong><span style="color:#ff0000;">②</span></strong>按照A的第2、3、4列，对A进行分组。pig会找出所有第2、3、4列的组合，并按照升序进行排列，然后将它们与对应的包A整合起来，得到如下的数据结构：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>B: {group: (col2: int,col3: int,col4: int),A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}}<br></pre></p>
<p></p><p>可见，A的第2、3、4列的组合被pig赋予了一个别名：<span style="color:#0000ff;">group</span>，这很形象。同时我们也观察到，B的每一行其实就是由一个group和若干个A组成的&mdash;&mdash;注意，是若干个A。这里之所以只显示了一个A，是因为这里表示的是数据结构，而不表示具体数据有多少组。<br><br>实际的数据为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>((1,2,3),{(a,1,2,3,4.2,9.8),(a,1,2,3,1.4,0.2)})<br>((1,2,5),{(a,1,2,5,7.7,5.9)})<br>((3,0,5),{(a,3,0,5,3.5,2.1)})<br>((7,9,9),{(b,7,9,9,,),(a,7,9,9,2.6,6.2)})<br></pre></p>
<p></p><p>可见，与前面所说的一样，组合（1，2，3）对应了两行数据，组合（7，9，9）也对应了两行数据。<br><br>这个时候，B的结构就不那么明朗了，可能与你想像中有一点不一样了。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><strong><span style="color:#ff0000;">③</span></strong>计算每一种组合下的最后两列的平均值。<br><br>根据上面得到的B的数据，你可以把B想像成一行一行的数据（只不过这些行不是对称的），FOREACH 的作用是对 B 的每一行数据进行遍历，然后进行计算。<br><br>GENERATE 可以理解为要生成什么样的数据，这里的 group 就是上一步操作中B的第一项数据（即pig为A的第2、3、4列的组合赋予的别名），所以它告诉了我们：在数据集 C 的每一行里，第一项就是B中的group&mdash;&mdash;类似于（1，2，5）这样的东西）。<br><br>而 AVG(A.col5) 这样的计算，则是调用了pig的一个求平均值的函数 AVG，用于对 A 的名为 col5 的列求平均值。前文说了，在加载数据到A的时候，我们已经给每一列起了个别名，col5就是倒数第二列。<br><br>到这里，可能有人要迷糊了：难道 AVG(A.col5) 不是表示对 A 的col5这一列求平均值吗？也就是说，在遍历B（FOREACH B）的每一行时候，计算结果都是相同的啊！<br><br>事实上并不是这样。我们遍历的是B，我们需要注意到，B的数据结构中，每一行数据里，一个group对应的是若干个A，因此，这里的 A.col5，指的是B的每一行中的A，而不是包含全部数据的那个A。拿B的第一行来举例：<br><br>((1,2,3),{(a,1,2,3,4.2,9.8),(a,1,2,3,1.4,0.2)})<br><br>遍历到B的这一行时，要计算AVG(A.col5)，pig会找到&nbsp;(a,1,2,3,4.2,9.8) 中的4.2，以及(a,1,2,3,1.4,0.2)中的1.4，加起来除以2，就得到了平均值。<br><br>同理，我们也知道了AVG(A.col6)是怎么算出来的。但还有一点要注意的：对(7,9,9)这个组，它对应的数据(b,7,9,9,,)里最后两列是无值的，这是因为我们的数据文件对应位置上不是有效数字，而是两个&ldquo;-&rdquo;，pig在加载数据的时候自动将它置为空了，并且计算平均值的时候，也不会把这一组数据考虑在内（相当于忽略这组数据的存在）。<br><br>到了这里，我们不难理解，为什么C的数据结构是这样的了：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>C: {group: (col2: int,col3: int,col4: int),double,double}<br></pre></p>
<p></p><p><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><strong><span style="color:#ff0000;">④</span></strong>DUMP C就是将C中的数据输出到控制台。如果要输出到文件，需要使用：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>STORE C INTO &#39;output&#39;;<br></pre></p>
<p></p><p>这样pig就会在当前目录下新建一个&ldquo;output&rdquo;目录（该目录必须事先不存在），并把结果文件放到该目录下。</p><p></p>
<p></p><p>请想像一下，如果要实现相同的功能，用Java或C++写一个Map-Reduce应用程序需要多少时间？可能仅仅是写一个build.xml或者Makefile，所需的时间就是写这段pig代码的几十倍了！<br><br>正因为pig有如此优势，它才得到了广泛应用。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（3）</span>怎样统计数据行数<br><br>在SQL语句中，要统计表中数据的行数，很简单：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>SELECT COUNT(*) FROM table_name WHERE condition<br></pre></p>
<p></p><p>在pig中，也有一个COUNT函数，在pig手册中，对COUNT函数有这样的说明：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>Computes the number of elements in a bag.</p><br><p></p>
<p></p><p>假设要计算数据文件a.txt的行数：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>a    1    2    3    4.2    9.8<br>a    3    0    5    3.5    2.1<br>b    7    9    9    -    -<br>a    7    9    9    2.6    6.2<br>a    1    2    5    7.7    5.9<br>a    1    2    3    1.4    0.2<br></pre></p>
<p></p><p>你是否可以这样做呢：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>B = COUNT(*);<br>DUMP B;<br></pre></p>
<p></p><p>答案是：绝对不行。pig会报错。pig手册中写得很明白：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>Note: You cannot use the tuple designator (<em>) with COUNT; that is, COUNT(</em>) will not work.</p><br><p></p>
<p></p><p>那么，这样对某一列计数行不行呢：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>B = COUNT(A.col2);<br></pre></p>
<p></p><p>答案是：仍然不行。pig会报错。<br><br>这就与我们想像中的&ldquo;正确做法&rdquo;有点不一样了：我为什么不能直接统计一个字段的数目有多少呢？刚接触pig的时候，一定非常疑惑这样明显&ldquo;不应该出错&rdquo;的写法为什么行不通。<br><br>要统计A中含col2字段的数据有多少行，正确的做法是：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>B = GROUP A ALL;<br>C = FOREACH B GENERATE COUNT(A.col2);<br>DUMP C;<br></pre></p>
<p></p><p>输出结果：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(6)<br></pre></p>
<p></p><p>表明有6行数据。<br><br>如此麻烦？没错。这是由pig的数据结构决定的。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>在这个例子中，统计COUNT(A.col2)和COUNT(A)的结果是一样的，但是，如果col2这一列中含有空值：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>a    1    2    3    4.2    9.8<br>a        0    5    3.5    2.1<br>b    7    9    9    -    -<br>a    7    9    9    2.6    6.2<br>a    1    2    5    7.7    5.9<br>a    1    2    3    1.4    0.2<br></pre></p>
<p></p><p>则以下pig程序及执行结果为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>grunt&gt; B = GROUP A ALL;<br>grunt&gt; C = FOREACH B GENERATE COUNT(A.col2);<br>grunt&gt; DUMP C;<br>(5)<br></pre></p>
<p></p><p>可见，结果为5行。那是因为你LOAD数据的时候指定了col2的数据类型为int，而a.txt的第二行数据是空的，因此数据加载到A以后，有一个字段就是空的：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DUMP A;<br>(a,1,2,3,4.2,9.8)<br>(a,,0,5,3.5,2.1)<br>(b,7,9,9,,)<br>(a,7,9,9,2.6,6.2)<br>(a,1,2,5,7.7,5.9)<br>(a,1,2,3,1.4,0.2)<br></pre></p>
<p></p><p>在COUNT的时候，null的字段不会被计入在内，所以结果是5。</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>The COUNT function follows syntax semantics and ignores nulls. What this means is that a tuple in the bag will not be counted if the first field in this tuple is NULL. If you want to include NULL values in the count computation, use COUNT_STAR.</p><br><p></p>
<p></p><p><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a></p><p></p>
<p><div><br><span style="background-color:#00ff00;">（4）</span><span style="color:#ff0000;">FLATTEN</span>操作符的作用</div></p>
<p><div><br>这个玩意一开始还是挺让我费解的。从字面上看，flatten就是&ldquo;弄平&rdquo;的意思，但是在对一个pig的数据结构操作时，flatten到底是&ldquo;弄平&rdquo;了什么，又有什么作用呢？<br><br>我们还是采用前面的a.txt数据文件来说明：</div></p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>a    1    2    3    4.2    9.8<br>a    3    0    5    3.5    2.1<br>b    7    9    9    -    -<br>a    7    9    9    2.6    6.2<br>a    1    2    5    7.7    5.9<br>a    1    2    3    1.4    0.2<br></pre><br></p></div><p></p>
<p></p><p>如果我们按照前文的做法，计算多维度组合下的最后两列的平均值，则：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>grunt&gt; B = GROUP A BY (col2, col3, col4);<br>grunt&gt; C = FOREACH B GENERATE group, AVG(A.col5), AVG(A.col6);<br>grunt&gt; DUMP C;<br>((1,2,3),2.8,5.0)<br>((1,2,5),7.7,5.9)<br>((3,0,5),3.5,2.1)<br>((7,9,9),2.6,6.2)<br></pre></p>
<p></p><p>可见，输出结果中，每一行的第一项是一个tuple（元组），我们来试试看 FLATTEN 的作用：</p><p></p>
<p><pre class="brush:csharp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br>grunt&gt; B = GROUP A BY (col2, col3, col4);<br>grunt&gt; C = FOREACH B GENERATE FLATTEN(group), AVG(A.col5), AVG(A.col6);<br>grunt&gt; DUMP C;<br>(1,2,3,2.8,5.0)<br>(1,2,5,7.7,5.9)<br>(3,0,5,3.5,2.1)<br>(7,9,9,2.6,6.2)<br></pre></p>
<p></p><p>看到了吗？被 FLATTEN 的group本来是一个元组，现在变成了扁平的结构了。按照pig文档的说法，FLATTEN用于对元组（tuple）和包（bag）&ldquo;解嵌套&rdquo;（un-nest）：</p><p></p>
<p><blockquote></blockquote></p>
<p><div><br>The FLATTEN operator looks like a UDF syntactically, but it is actually an operator that changes the structure of tuples and bags in a way that a UDF cannot. Flatten un-nests tuples as well as bags. The idea is the same, but the operation and result is different for each type of structure.</div></p>
<p><div><br>&nbsp;</div></p>
<p><div><br>For tuples, flatten substitutes the fields of a tuple in place of the tuple. For example, consider a relation that has a tuple of the form (a, (b, c)). The expression GENERATE $0, flatten($1), will cause that tuple to become (a, b, c).</div><br></p>
<p></p><p><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>所以我们就看到了上面的结果。<br><br>在有的时候，不&ldquo;解嵌套&rdquo;的数据结构是不利于观察的，输出这样的数据可能不利于外围数程序的处理（例如，pig将数据输出到磁盘后，我们还需要用其他程序做后续处理，而对一个元组，输出的内容里是含括号的，这就在处理流程上又要多一道去括号的工序），因此，FLATTEN提供了一个让我们在某些情况下可以清楚、方便地分析数据的机会。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（5）</span>关于<span style="color:#ff0000;">GROUP</span>操作符<br><br>在上文的例子中，已经演示了GROUP操作符会生成什么样的数据。在这里，需要说得更理论一些：</p><p></p>
<p><ul></ul></p>
<p><li><br>用于GROUP的key如果多于一个字段（正如本文前面的例子），则GROUP之后的数据的key是一个元组（tuple），否则它就是与用于GROUP的key相同类型的东西。</li></p>
<p><li><br>GROUP的结果是一个关系（relation），在这个关系中，每一组包含一个元组（tuple），这个元组包含两个字段：<strong><span style="color:#008080;">（1）</span></strong>第一个字段被命名为&ldquo;<span style="color:#0000ff;">group</span>&rdquo;&mdash;&mdash;<span style="color:#ff0000;">这一点非常容易与GROUP关键字相混淆</span>，但请区分开来。该字段的类型与用于GROUP的key类型相同。<strong><span style="color:#008080;">（2）</span></strong>第二个字段是一个包（bag），它的类型与被GROUP的关系的类型相同。</li><br></p>
<p></p><p><span style="background-color:#00ff00;">（6）</span>把数据当作&ldquo;元组&rdquo;（tuple）来加载<br><br>还是假设有如下数据：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>a    1    2    3    4.2    9.8<br>a    3    0    5    3.5    2.1<br>b    7    9    9    -    -<br>a    7    9    9    2.6    6.2<br>a    1    2    5    7.7    5.9<br>a    1    2    3    1.4    0.2<br></pre></p>
<p></p><p>如果我们按照以下方式来加载数据：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double);<br></pre></p>
<p></p><p>那么得到的A的数据结构为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE A;<br>A: {col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double}<br></pre></p>
<p></p><p>如果你要把A当作一个元组（tuple）来加载：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (T : tuple (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double));<br></pre></p>
<p></p><p>也就是想要得到这样的数据结构：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE A;<br>A: {T: (col1: chararray,col2: int,col3: int,col4: int,col5: double,col6: double)}<br></pre></p>
<p></p><p>那么，上面的方法将得到一个空的A：</p><p></p>
<p><pre class="brush:csharp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DUMP A;<br>()<br>()<br>()<br>()<br>()<br>()<br></pre></p>
<p></p><p>那是因为数据文件a.txt的结构不适合于这样加载成元组（tuple）。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>如果有数据文件b.txt：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat b.txt<br>(a,1,2,3,4.2,9.8)<br>(a,3,0,5,3.5,2.1)<br>(b,7,9,9,-,-)<br>(a,7,9,9,2.6,6.2)<br>(a,1,2,5,7.7,5.9)<br>(a,1,2,3,1.4,0.2)<br></pre></p>
<p></p><p>则使用上面所说的加载方法及结果为：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;b.txt&#39; AS (T : tuple (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double));<br>grunt&gt; DUMP A;<br>((a,1,2,3,4.2,9.8))<br>((a,3,0,5,3.5,2.1))<br>((b,7,9,9,,))<br>((a,7,9,9,2.6,6.2))<br>((a,1,2,5,7.7,5.9))<br>((a,1,2,3,1.4,0.2))<br></pre></p>
<p></p><p>可见，加载的数据的结构确实被定义成了元组（tuple）。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（7）</span>在多维度组合下，如何计算某个维度组合里的不重复记录的条数<br><br>以数据文件 c.txt 为例：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat c.txt<br>a    1    2    3    4.2    9.8    100<br>a    3    0    5    3.5    2.1    200<br>b    7    9    9    -    -    300<br>a    7    9    9    2.6    6.2    300<br>a    1    2    5    7.7    5.9    200<br>a    1    2    3    1.4    0.2    500<br></pre></p>
<p></p><p>问题：如何计算在第2、3、4列的所有维度组合下，最后一列不重复的记录分别有多少条？例如，第2、3、4列有一个维度组合是（1，2，3），在这个维度维度下，最后一列有两种值：100 和 500，因此不重复的记录数为2。同理可求得其他的记录条数。<br><br>pig代码及输出结果如下：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;c.txt&#39; AS (col1:chararray, col2:int, col3:int, col4:int, col5:double, col6:double, col7:int);<br>grunt&gt; B = GROUP A BY (col2, col3, col4);<br>grunt&gt; C = FOREACH B {D = DISTINCT A.col7; GENERATE group, COUNT(D);};<br>grunt&gt; DUMP C;<br>((1,2,3),2)<br>((1,2,5),1)<br>((3,0,5),1)<br>((7,9,9),1)<br></pre></p>
<p></p><p>我们来看看每一步分别生成了什么样的数据：<br><br><strong><span style="color:#ff0000;">①</span></strong>LOAD不用说了，就是加载数据；<br><br><strong><span style="color:#ff0000;">②</span></strong>GROUP也不用说了，和前文所说的一样。GROUP之后得到了这样的数据：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DUMP B;<br>((1,2,3),{(a,1,2,3,4.2,9.8,100),(a,1,2,3,1.4,0.2,500)})<br>((1,2,5),{(a,1,2,5,7.7,5.9,200)})<br>((3,0,5),{(a,3,0,5,3.5,2.1,200)})<br>((7,9,9),{(b,7,9,9,,,300),(a,7,9,9,2.6,6.2,300)})<br></pre></p>
<p></p><p>其实到这里，我们肉眼就可以看出来最后要求的结果是什么了，当然，必须要由pig代码来完成，要不然怎么应对海量数据？<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><strong><span style="color:#ff0000;">③</span></strong>这里的 FOREACH 与前面有点不一样，这就是所谓的&ldquo;<span style="color:#0000ff;">嵌套的FOREACH</span>&rdquo;。第一次看到这种写法，肯定会觉得很奇怪。先看一下用于<span style="color:#0000ff;">去重</span>的<span style="color:#ff0000;">DISTINCT</span>关键字的说明：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>Removes duplicate tuples in a relation.</p><br><p></p>
<p></p><p>然后再解释一下：FOREACH 是对B的每一行进行遍历，其中，B的每一行里含有一个包（bag），每一个包中含有若干元组（tuple）A，因此，FOREACH 后面的大括号里的操作，其实是对所谓的&ldquo;内部包&rdquo;（<span style="color:#ff0000;">inner bag</span>）的操作（详情请参看<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html#FOREACH" target="_blank"><span style="color:#800080;">FOREACH的说明</span></a>），在这里，我们指定了对A的col7这一列进行去重，去重的结果被命名为D，然后再对D计数（COUNT），就得到了我们想要的结果。<br><br><strong><span style="color:#ff0000;">④</span></strong>输出结果数据，与前文所述的差不多。<br><br>这样就达成了我们的目的。从总体上说，刚接触pig不久的人会觉得这些写法怪怪的，就是扭不过来，但是要坚持，时间长了，连倒影也会让你觉得是正的了。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（8）</span>如何将关系（relation）转换为标量（scalar）<br><br>在前文中，我们要统计符合某些条件的数据的条数，使用了COUNT函数来计算，但在COUNT之后，我们得到的还是一个关系（relation），而不是一个标量的数字，如何把一个关系转换为标量，从而可以在后续处理中便于使用呢？<br><br>具体请看<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html#Casting+Relations+to+Scalars" target="_blank">这个链接</a>。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（9）</span>pig中如何使用shell进行辅助数据处理<br><br>pig中可以嵌套使用shell进行辅助处理，下面，就以一个实际的例子来说明。<br><br>假设我们在某一步pig处理后，得到了类似于下面 b.txt 中的数据：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat b.txt<br>1    5    98    =    7<br>34    8    6    3    2<br>62    0    6    =    65<br></pre></p>
<p></p><p>问题：如何将数据中第4列中的&ldquo;=&rdquo;符号全部替换为9999？<br><br>pig代码及输出结果如下：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;b.txt&#39; AS (col1:int, col2:int, col3:int, col4:chararray, col5:int);<br>grunt&gt; B = STREAM A THROUGH <code>awk &amp;#39;{if($4 == &amp;quot;=&amp;quot;) print $1&amp;quot;\t&amp;quot;$2&amp;quot;\t&amp;quot;$3&amp;quot;\t9999\t&amp;quot;$5; else print $0}&amp;#39;</code>;<br>grunt&gt; DUMP B;<br>(1,5,98,9999,7)<br>(34,8,6,3,2)<br>(62,0,6,9999,65)<br></pre></p>
<p></p><p>我们来看看这段代码是如何做到的：<br><br><strong><span style="color:#ff0000;">①</span></strong>加载数据，这个没什么好说的。<br><br><strong><span style="color:#ff0000;">②</span></strong>通过&ldquo;STREAM &hellip; THROUGH &hellip;&rdquo;的方式，我们可以调用一个shell语句，用该shell语句对A的每一行数据进行处理。此处的shell逻辑为：当某一行数据的第4列为&ldquo;=&rdquo;符号时，将其替换为&ldquo;9999&rdquo;；否则就照原样输出这一行。<br><br><strong><span style="color:#ff0000;">③</span></strong>输出B，可见结果正确。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（10）</span>向pig脚本中传入参数<br><br>假设你的pig脚本输出的文件是通过外部参数指定的，则此参数不能写死，需要传入。在pig中，使用传入的参数如下所示：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>STORE A INTO &#39;$output_dir&#39;;<br></pre></p>
<p></p><p>则这个&ldquo;output_dir&rdquo;就是个传入的参数。在调用这个pig脚本的shell脚本中，我们可以这样传入参数：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>pig -param output_dir=&quot;/home/my_ourput_dir/&quot; my_pig_script.pig<br></pre></p>
<p></p><p>这里传入的参数&ldquo;output_dir&rdquo;的值为&ldquo;/home/my_output_dir/&rdquo;。<br><br><span style="color: rgb(255, 255, 255); font-family: arial, helvetica, sans-serif; font-size: 14px; line-height: 20px; text-align: left; background-color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（11）</span>就算是同样一段pig代码，多次计算所得的结果也有可能是不同的<br><br>例如用<span style="color:#ff0000;">AVG</span>函数来计算平均值时，同样一段pig代码，多次计算所得的结果中，小数点的最后几位也有可能是不相同的（当然也有可能相同），大概是因为精度的原因吧。不过，一般来说小数点的最后几位已经不重要了。例如我对一个数据集进行处理后，小数点后13位才开始有不同，这样的精度完全足够了。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（12）</span>如何编写及使用自定义函数（UDF）<br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color:#0000ff;">Apache Pig中文教程（进阶）</span></a>》</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（13）</span>什么是聚合函数（Aggregate Function）<br><br>在pig中，聚合函数就是那些接受一个输入包（bag），返回一个标量（scalar）值的函数。COUNT函数就是一个例子。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（14）</span>COGROUP做了什么<br><br>与GROUP操作符一样，<span style="color:#ff0000;"><span style="background-color:#e6e6fa;">CO</span>GROUP</span>也是用来分组的，不同的是，COGROUP可以按多个关系中的字段进行分组。<br><br>还是以一个实例来说明，假设有以下两个数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost pig]$ cat a.txt<br>uidk    12    3<br>hfd    132    99<br>bbN    463    231<br>UFD    13    10</pre></p>
<p>[root@localhost pig]$ cat b.txt<br>908    uidk    888<br>345    hfd    557<br>28790    re    00000<br></p>
<p></p><p>现在我们用pig做如下操作及得到的结果为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (acol1:chararray, acol2:int, acol3:int);<br>grunt&gt; B = LOAD &#39;b.txt&#39; AS (bcol1:int, bcol2:chararray, bcol3:int);<br>grunt&gt; C = COGROUP A BY acol1, B BY bcol2;<br>grunt&gt; DUMP C;<br>(re,{},{(28790,re,0)})<br>(UFD,{(UFD,13,10)},{})<br>(bbN,{(bbN,463,231)},{})<br>(hfd,{(hfd,132,99)},{(345,hfd,557)})<br>(uidk,{(uidk,12,3)},{(908,uidk,888)})<br></pre></p>
<p></p><p>每一行输出的第一项都是分组的key，第二项和第三项分别都是一个包（bag），其中，第二项是根据前面的key找到的A中的数据包，第三项是根据前面的key找到的B中的数据包。<br><br>来看看第一行输出：&ldquo;re&rdquo;作为group的key时，其找不到对应的A中的数据，因此第二项就是一个空的包&ldquo;{}&rdquo;，&ldquo;re&rdquo;这个key在B中找到了对应的数据（28790 &nbsp; &nbsp;re &nbsp; &nbsp;00000），因此第三项就是包{(28790,re,0)}。<br><br>其他输出数据也类似。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（15）</span>安装pig后，运行pig命令时提示&ldquo;Cannot find hadoop configurations in classpath&rdquo;等错误的解决办法<br><br>pig安装好后，运行pig命令时提示以下错误：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>ERROR org.apache.pig.Main - ERROR 4010: Cannot find hadoop configurations in classpath (neither hadoop-site.xml nor core-site.xml was found in the classpath).If you plan to use local mode, please put -x local option in command line</p><br><p></p>
<p></p><p>显而易见，提示找不到与hadoop相关的配置文件。所以我们需要把hadoop安装目录下的&ldquo;conf&rdquo;子目录添加到系统环境变量PATH中：<br><br>修改 /etc/profile 文件，添加：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>export HADOOP_HOME=/usr/local/hadoop<br>export PIG_CLASSPATH=$HADOOP_HOME/conf</pre></p>
<p>PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$PIG_CLASSPATH:$PATH<br></p>
<p></p><p>然后重新加载 /etc/profile 文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>source /etc/profile<br></pre></p>
<p></p><p><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color:#ffffff;">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（16）</span>piggybank是什么东西</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>Pig also hosts a UDF repository called piggybank that allows users to share UDFs that they have written.</p><br><p></p>
<p></p><p>说白了就是Apache把大家写的自定义函数放在一块儿，起了个名字，就叫做piggybank。你可以把它理解为一个SVN代码仓库。具体请看<a href="https://cwiki.apache.org/confluence/display/PIG/PiggyBank" target="_blank"><span style="color:#ff0000;">这里</span></a>。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（17）</span>UDF的构造函数会被调用几次<br><br>你可能会想在UDF的构造函数中做一些初始化的工作，例如创建一些文件，等等。但是你不能假设UDF的构造函数只被调用一次，因此，如果你要在构造函数中做一些只能做一次的工作，你就要当心了&mdash;&mdash;可能会导致错误。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（18）</span>LOAD数据时，如何一次LOAD多个目录下的数据<br><br>例如，我要LOAD两个HDFS目录下的数据：/abc/2010 和 /abc/2011，则我们可以这样写LOAD语句：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;/abc/201{0,1}&#39;;<br></pre></p>
<p></p><p><br><span style="background-color:#00ff00;">（19）</span>怎样自己写一个UDF中的加载函数(load function)<br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color: rgb(0, 0, 255); ">Apache Pig中文教程（进阶）</span></a>》</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（20）</span>重载(overloading)一个UDF<br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color: rgb(0, 0, 255); ">Apache Pig中文教程（进阶）</span></a>》。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（21）</span>pig运行不起来，提示&ldquo;<span style="color:#b22222;">org.apache.hadoop.ipc.Client - Retrying connect to server:&nbsp;</span><br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color: rgb(0, 0, 255); ">Apache Pig中文教程（进阶）</span></a>》</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（22）</span>用含有null的字段来GROUP，结果会如何<br><br>假设有数据文件 a.txt 内容为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>1    2    5<br>1        3<br>1    3<br>6    9    8<br></pre></p>
<p></p><p>其中，每两列数据之间是用tab分割的，第二行的第2列、第三行的第3列没有内容（也就是说，加载到Pig里之后，对应的数据会变成null），如果把这些数据按第1、第2列来GROUP的话，第1、2列中含有null的行会被忽略吗？<br><br>来做一下试验：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int);<br>B = GROUP A BY (col1, col2);<br>DUMP B;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>((1,2),{(1,2,5)})<br>((1,3),{(1,3,)})<br>((1,),{(1,,3)})<br>((6,9),{(6,9,8)})<br></pre></p>
<p></p><p>从上面的结果（第三行）可见，原数据中第1、2列里含有null的行也被计入在内了，也就是说，GROUP操作是不会忽略null的，这与COUNT有所不同（见本文前面的部分）。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（23）</span>如何统计数据中某些字段的组合有多少种<br><br>假设有如下数据：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost]# cat a.txt<br>1    3    4    7<br>1    3    5    4<br>2    7    0    5<br>9    8    6    6<br></pre></p>
<p></p><p>现在我们要统计第1、2列的不同组合有多少种，对本例来说，组合有三种：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>1    3<br>2    7<br>9    8<br></pre></p>
<p></p><p>也就是说我们要的答案是3。<br><br>用Pig怎么计算？<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>先写出全部的Pig代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int, col4:int);<br>B = GROUP A BY (col1, col2);<br>C = GROUP B ALL;<br>D = FOREACH C GENERATE COUNT(B);<br>DUMP D;<br></pre></p>
<p></p><p>然后再来看看这些代码是如何计算出上面的结果的：<br><br><strong><span style="color:#ff0000;">①</span></strong>第一行代码加载数据，没什么好说的。<br><br><strong><span style="color:#ff0000;">②</span></strong>第二行代码，得到第1、2列数据的所有组合。B的数据结构为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE B;<br>B: {group: (col1: int,col2: int),A: {col1: int,col2: int,col3: int,col4: int}}<br></pre></p>
<p></p><p>把B DUMP出来，得到：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>((1,3),{(1,3,4,7),(1,3,5,4)})<br>((2,7),{(2,7,0,5)})<br>((9,8),{(9,8,6,6)})<br></pre></p>
<p></p><p>非常明显，(1,3)，(2,7)，(9,8)的所有组合已经被排列出来了，这里得到了若干行数据。下一步我们要做的就是统计这样的数据一共有多少行，也就得到了第1、2列的组合有多少组。<br><br><strong><span style="color:#ff0000;">③</span></strong>第三和第四行代码，就实现了统计数据行数的功能。参考本文前面部分的&ldquo;怎样统计数据行数&rdquo;一节。就明白这两句代码是什么意思了。<br><br>这里需要特别说明的是：<br><br><strong><span style="color:#0000ff;">a)</span></strong>为什么倒数第二句代码中是COUNT(B)，而不是COUNT(group)？<br><br>我们是对C进行FOREACH，所以要先看看C的数据结构：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE C;<br>C: {group: chararray,B: {group: (col1: int,col2: int),A: {col1: int,col2: int,col3: int,col4: int}}}<br></pre></p>
<p></p><p>可见，你可以把C想像成一个map的结构，key是一个group，value是一个包（bag），它的名字是B，这个包中有N个元素，每一个元素都对应到②中所说的一行。根据②的分析，我们就是要统计B中元素的个数，因此，这里当然就是COUNT(B)了。<br><br><strong><span style="color:#0000ff;">b)</span></strong>COUNT函数的作用是统计一个包（bag）中的元素的个数：</p><p></p>
<p><blockquote></blockquote></p>
<p><div><br>COUNT</div></p>
<p><div><br>Computes the number of elements in a bag.</div><br></p>
<p><div><br>从C的数据结构看，B是一个bag，所以COUNT函数是可以用于它的。<br><br>如果你试图把COUNT应用于一个非bag的数据结构上，会发生错误，例如：</div></p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>java.lang.ClassCastException: org.apache.pig.data.BinSedesTuple cannot be cast to org.apache.pig.data.DataBag<br></pre><br></p>
<p></p><p>这是把Tuple传给COUNT函数时发生的错误。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（24）</span>两个整型数相除，如何转换为浮点型，从而得到正确的结果<br><br>这个问题其实很傻，或许不用说你也知道了：假设有int a = 3 和 int b = 2两个数，在大多数编程语言里，a/b得到的是1，想得到正确结果1.5的话，需要转换为float再计算。在Pig中其实和这种情况一样，下面就拿几行数据来做个实验：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat a.txt<br>3    2<br>4    5<br></pre></p>
<p></p><p>在Pig中：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);<br>grunt&gt; B = FOREACH A GENERATE col1/col2;<br>grunt&gt; DUMP B;<br>(1)<br>(0)<br></pre></p>
<p></p><p>可见，不加类型转换的计算结果是取整之后的值。<br><br>那么，转换一下试试：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);<br>grunt&gt; B = FOREACH A GENERATE (float)(col1/col2);<br>grunt&gt; DUMP B;<br>(1.0)<br>(0.0)<br></pre></p>
<p></p><p>这样转换还是不行的，这与大多数编程语言的结果一致&mdash;&mdash;它只是把取整之后的数再转换为浮点数，因此当然是不行的。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>正确的做法应该是：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);<br>grunt&gt; B = FOREACH A GENERATE (float)col1/col2;<br>grunt&gt; DUMP B;<br>(1.5)<br>(0.8)<br></pre></p>
<p></p><p>或者这样也行：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int);<br>grunt&gt; B = FOREACH A GENERATE col1/(float)col2;<br>grunt&gt; DUMP B;<br>(1.5)<br>(0.8)<br></pre></p>
<p></p><p>这与我们的通常做法是一致的，因此，你要做除法运算的时候，需要注意这一点。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（25）</span>UNION的一个例子<br><br>假设有两个数据文件为：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>0    3<br>1    5<br>0    8</pre></p>
<p>[root@localhost ~]# cat 2.txt<br>1    6<br>0    9<br></p>
<p></p><p>现在要求出：在第一列相同的情况下，第二列的和分别为多少？<br><br>例如，第一列为 1 的时候，第二列有5和6两个值，和为11。同理，第一列为0的时候，第二列的和为 3+8+9=20。<br><br>计算此问题的Pig代码如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (a: int, b: int);<br>B = LOAD &#39;2.txt&#39; AS (c: int, d: int);<br>C = UNION A, B;<br>D = GROUP C BY $0;<br>E = FOREACH D GENERATE FLATTEN(group), SUM(C.$1);<br>DUMP E;<br></pre></p>
<p></p><p>输出为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(0,20)<br>(1,11)<br></pre></p>
<p></p><p><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>我们来看看每一步分别做了什么：<br><br><strong><span style="color:#ff0000;">①</span></strong>第1行、第2行代码分别加载数据到关系A、B中，没什么好说的。<br><br><strong><span style="color:#ff0000;">②</span></strong>第3行代码，将关系A、B合并起来了。合并后的数据结构为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE C;<br>C: {a: int,b: int}<br></pre></p>
<p></p><p>其数据为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DUMP C;<br>(0,3)<br>(1,5)<br>(0,8)<br>(1,6)<br>(0,9)<br></pre></p>
<p></p><p><strong><span style="color:#ff0000;">③</span></strong>第4行代码按第1列（即$0）进行分组，分组后的数据结构为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DESCRIBE D;<br>D: {group: int,C: {a: int,b: int}}<br></pre></p>
<p></p><p>其数据为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; DUMP D;<br>(0,{(0,9),(0,3),(0,8)})<br>(1,{(1,5),(1,6)})<br></pre></p>
<p></p><p><strong><span style="color:#ff0000;">④</span></strong>最后一行代码，遍历D，将D中每一行里的所有bag(即C)的第2列(即$1)进行累加，就得到了我们要的结果。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（26）</span>错误&ldquo;<span style="color:#0000ff;">ERROR org.apache.pig.tools.grunt.Grunt - ERROR 2042: Error in new logical plan. Try -Dpig.usenewlogicalplan=false.</span>&rdquo;的可能原因<br><br><strong><span style="color:#ff0000;">①</span></strong>Pig的bug，详见<a href="https://issues.apache.org/jira/browse/PIG-1683" target="_blank">此链接</a>；<br><br><strong><span style="color:#ff0000;">②</span></strong>其他原因。我遇到并解决了一例。具体的代码不便在此陈列，但是基本可以说是由于自己写的Pig代码对复杂数据结构的处理不当导致的，后来我尝试更改了一种实现方式，就绕过了这个问题。关于这点，确实还是要具体问题具体分析的，在这里没有实例的话，无法给大家一个明确的解决问题的指南。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（27）</span>如何在Pig中使用正则表达式对字符串进行匹配<br><br>假设你有如下数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat a.txt<br>1    <a href="http://ui.qq.com/abcd.html" target="_blank" rel="noopener">http://ui.qq.com/abcd.html</a><br>5    <a href="http://tr.qq.com/743.html" target="_blank" rel="noopener">http://tr.qq.com/743.html</a><br>8    <a href="http://vid.163.com/trees.php" target="_blank" rel="noopener">http://vid.163.com/trees.php</a><br>9    http:auto.qq.com/us.php<br></pre></p>
<p></p><p>现在要找出该文件中，第二列符合&ldquo;<span style="color:#ff0000;"><em>//</em>.qq.com/*</span>&rdquo;模式的所有行（此处只有前两行符合条件），怎么做？<br><br>Pig代码如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1: int, col2: chararray);<br>B = FILTER A BY col2 matches &#39;.<em>//.</em>.qq.com/.*&#39;;<br>DUMP B;<br></pre></p>
<p></p><p>我们看到，matches关键字对 col2 进行了正则匹配，它使用的是Java格式的正则表达式匹配规则。<br><br><span style="color:#ff0000;">.&nbsp;</span>表示任意字符，<strong><span style="color:#ff0000;">*&nbsp;</span></strong>表示字符出现任意次数；<strong><span style="color:#ff0000;">.&nbsp;</span></strong>对&nbsp;<span style="color:#ff0000;">.&nbsp;</span>进行了转义，表示匹配&nbsp;<span style="color:#ff0000;">.&nbsp;</span>这个字符；<span style="color:#ff0000;">/&nbsp;</span>就是表示匹配&nbsp;<strong><span style="color:#ff0000;">/&nbsp;</span></strong>这个字符。<br><br>这里需要注意的是，在引号中，用于转义的字符&nbsp;<strong><span style="color:#ff0000;">\&nbsp;</span></strong>需要打两个才能表示一个，所以上面的&nbsp;<strong><span style="color:#ff0000;">\.&nbsp;</span></strong>就是与正则中的&nbsp;<strong><span style="color:#ff0000;">.&nbsp;</span></strong>是一样的，即匹配<strong>&nbsp;</strong><span style="color:#ff0000;">.&nbsp;</span>这个字符。所以，如果你要匹配数字的话，应该用这种写法（<strong><span style="color:#ff0000;">\d</span></strong>表示匹配数字，在引号中必须用<strong><span style="color:#ff0000;">\d</span></strong>）：</p><p></p>
<p><pre class="brush:csharp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>B = FILTER A BY (col matches &#39;\d.*&#39;);<br></pre></p>
<p></p><p><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>最后输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1,<a href="http://ui.qq.com/abcd.html" target="_blank" rel="noopener">http://ui.qq.com/abcd.html</a>)<br>(5,<a href="http://tr.qq.com/743.html" target="_blank" rel="noopener">http://tr.qq.com/743.html</a>)<br></pre></p>
<p></p><p>可见结果是正确的。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（28）</span>如何截取一个字符串中的某一段<br><br>在处理数据时，如果你想提取出一个日期字符串的年份，例如提取出&ldquo;2011-10-26&rdquo;中的&ldquo;2011&rdquo;，可以用内置函数 <span style="color:#0000ff;">SUBSTRING</span> 来实现：</p><p></p>
<p><blockquote></blockquote></p>
<p><div><br><span style="font-size:20px;">SUBSTRING</span></div></p>
<p><div><br>Returns a substring from a given string.</div></p>
<p><div><br><span style="font-size:18px;">Syntax</span></div></p>
<p><div><br>SUBSTRING(string, startIndex, stopIndex)</div><br></p>
<p></p><p>下面举一个例子。假设有数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat a.txt<br>2010-05-06    abc<br>2008-06-18    uio<br>2011-10-11    tyr<br>2010-12-23    fgh<br>2011-01-05    vbn<br></pre></p>
<p></p><p>第一列是日期，现在要找出所有不重复的年份有哪些，可以这样做：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (dateStr: chararray, flag: chararray);<br>B = FOREACH A GENERATE SUBSTRING(dateStr, 0, 4);<br>C = DISTINCT B;<br>DUMP C;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(2008)<br>(2010)<br>(2011)<br></pre></p>
<p></p><p>可见达到了我们想要的效果。<br><br>上面的代码太简单了，不必多言，唯一需要说明一下的是 SUBSTRING 函数，它的第一个参数是要截取的字符串，第二个参数是起始索引（从0开始），第三个参数是结束索引。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（29）</span>如何拼接两个字符串<br><br>假设有以下数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>abc    123<br>cde    456<br>fgh    789<br>ijk    200<br></pre></p>
<p></p><p>现在要把第一列和第二列作为字符串拼接起来，例如第一行会变成&ldquo;abc123&rdquo;，那么使用CONCAT这个求值函数（eval function）就可以做到：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: chararray, col2: int);<br>B = FOREACH A GENERATE CONCAT(col1, (chararray)col2);<br>DUMP B;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(abc123)<br>(cde456)<br>(fgh789)<br>(ijk200)<br></pre></p>
<p></p><p>注意这里故意在加载数据的时候把第二列指定为int类型，这是为了说明数据类型不一致的时候CONCAT会出错（你可以试验一下）：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1045: Could not infer the matching function for org.apache.pig.builtin.CONCAT as multiple or none of them fit. Please use an explicit cast.</p><br><p></p>
<p></p><p>所以在后面CONCAT的时候，对第二列进行了类型转换。<br><br>另外，如果数据文件内容为：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>5    123<br>7    456<br>8    789<br>0    200<br></pre></p>
<p></p><p>那么，如果对两列整数CONCAT：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: int, col2: int);<br>B = FOREACH A GENERATE CONCAT(col1, col2);<br></pre></p>
<p></p><p><span style="color:#ff0000;">同样也会出错</span>：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1045: Could not infer the matching function for org.apache.pig.builtin.CONCAT as multiple or none of them fit. Please use an explicit cast.</p><br><p></p>
<p></p><p>要注意这一点。<br><br>有人可能会问：要拼接几个字符串的话怎么办？CONCAT 套 CONCAT 就要可以了（有点笨，但管用）： <span style="color:#0000ff;">CONCAT(a, CONCAT(b, c))</span></p><p></p>
<p></p><p><span style="background-color:#00ff00;">（30）</span>如何求两个数据集的重合 &amp; 不同的数据类型JOIN会失败<br><br>假设有以下两个数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>123<br>456<br>789<br>200<br></pre></p>
<p></p><p>以及：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 2.txt<br>200<br>333<br>789<br></pre></p>
<p></p><p>现在要找出两个文件中，相同的数据有多少行，怎么做？这也就是所谓的求两个数据集的<span style="color:#ff0000;">重合</span>。<br><br>用关系操作符JOIN，我们可以达到这个目的。在处理海量数据时，经常会有求重合的需求。所以JOIN是Pig中一个极其重要的操作。<br><br>在本例中，两个文件中有两个相同的数据行：789以及200，因此，结果应该是2。<br><br>我们先来看看正确的代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (a: int);<br>B = LOAD &#39;2.txt&#39; AS (b: int);<br>C = JOIN A BY a, B BY b;<br>D = GROUP C ALL;<br>E = FOREACH D GENERATE COUNT(C);<br>DUMP E;<br></pre></p>
<p></p><p>解释一下：<br><br><span style="color:#ff0000;">①</span>第一、二行是加载数据，不必多言。<br><br><span style="color:#ff0000;">②</span>第三行按A的第1列、B的第二列进行&ldquo;结合&rdquo;，JOIN之后，a、b两列不相同的数据就被剔除掉了。C的数据结构为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>C: {A::a: int,B::b: int}<br></pre></p>
<p></p><p>C的数据为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(200,200)<br>(789,789)<br></pre></p>
<p></p><p><span style="color:#ff0000;">③</span>由于我们要统计的是数据行数，所以上面的Pig代码中的第4、5行就进行了计数的运算。<br><br><span style="color:#ff0000;">④</span>如果文件 2.txt 多一行数据&ldquo;200&rdquo;，结果会是什么？答案是：结果为3行。这个时候C的数据为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(200,200)<br>(200,200)<br>(789,789)<br></pre></p>
<p></p><p>所以如果你要去除重复的，还需要用DISTINCE对C处理一下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (a: int);<br>B = LOAD &#39;2.txt&#39; AS (b: int);<br>C = JOIN A BY a, B BY b;<br>uniq_C = DISTINCT C;<br>D = GROUP uniq_C ALL;<br>E = FOREACH D GENERATE COUNT(uniq_C);<br>DUMP E;<br></pre></p>
<p></p><p>这样得到的结果就是2了。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>尤其需要注意的是，如果JOIN的两列具有不同的数据类型，是会失败的。例如以下代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (a: int);<br>B = LOAD &#39;2.txt&#39; AS (b: chararray);<br>C = JOIN A BY a, B BY b;<br>D = GROUP C ALL;<br>E = FOREACH D GENERATE COUNT(C);<br>DUMP E;<br></pre></p>
<p><div><br>在语法上是没有错误的，但是一运行就会报错：</div></p>
<p><blockquote></blockquote></p>
<p><div><br>ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1107: Cannot merge join keys, incompatible types</div><br></p>
<p><div><br>这是因为a、b具有不同的类型：int和chararray。</div></p><p></p>
<p></p><p>    <span style="background-color:#00ff00;">（31）</span>使用三目运算符&ldquo; <span style="color:#ff0000;">? :</span> &rdquo;有时候必须加括号<br><br>假设有以下数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat a.txt<br>5    8    9<br>6        0<br>4    3    1<br></pre><br></p>
<p></p><p>其中，第二行的第二列数据是有缺失的，因此，加载数据之后，它会成为null。顺便废话一句，在处理海量数据时，数据有缺失是经常遇到的现象。<br><br>现在，我们如果要把所有缺失的数据填为 -1， 可以使用三目运算符来操作：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1:int, col2:int, col3:int);<br>B = FOREACH A GENERATE col1, ((col2 is null)? -1 : col2), col3;<br>DUMP B;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(5,8,9)<br>(6,-1,0)<br>(4,3,1)<br></pre></p>
<p></p><p><span style="color:#0000ff;">((col2 is null)? -1 : col2)</span> 的含义不用解释你也知道，就是当col2为null的时候将其置为-1，否则就保持原来的值，但是注意，它最外面是用括号括起来的，如果去掉括号，写成&nbsp;<span style="color:#0000ff;">(col2 is null)? -1 : col2</span>，那么就会有语法错误：</p><p></p>
<p><blockquote></blockquote></p>
<p><div><br>ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1000: Error during parsing. Encountered &quot; &quot;is&quot; &quot;is &quot;&quot; at line 1, column 36.</div></p>
<p><div><br>Was expecting one of （后面省略）</div><br></p>
<p><div><br>错误提示有点不直观。所以，有时候使用三目运算符是必须要使用括号的。</div></p><p></p>
<p></p><p>    <span style="background-color:#00ff00;">（32）</span>如何补上缺失的数据<br><br>通过前面的文章，我们已经知道了如何按自己的需求补上缺失的数据，那么这里还有一个例子，可以让你多了解一些特殊的情况。<br><br>数据文件如下：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>1    (4,9)<br>5<br>8    (3,0)<br>5    (9,2)<br>6<br></pre><br></p>
<p></p><p>这些数据的布局比较怪，我们要把它加载成什么样的schema呢？答：第一列为一个int，第二列为一个tuple，此tuple又含两个int。加载成这样的模式不是为了制造复杂度，而是为了说明后面的问题而设计的。<br><br>同时，我们也注意到，第二列数据是有缺失的。<br><br>问题：怎样求在第一列数据相同的情况下，第二列数据中的第一个整数的和分别为多少？<br><br>例如，第一列为1的数据只有一行（即第一行），因此，第二列的第一个整数的和就是4。<br><br>但是对最后一行，也就是第一列为6时，由于其第二列数据缺失，我们希望它输出的结果是0。<br><br>先来看看Pig代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (a:int, b:tuple(x:int, y:int));<br>B = FOREACH A GENERATE a, FLATTEN(b);<br>C = GROUP B BY a;<br>D = FOREACH C GENERATE group, SUM(B.x);<br>DUMP D;<br></pre></p>
<p></p><p>结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1,4)<br>(5,9)<br>(6,)<br>(8,3)<br></pre></p>
<p></p><p>我们注意到，(5,9) 这一行是由数据文件 1.txt 的第 2、4行计算得到的，其中，第2行数据有缺失，但这并不影响求和计算，因为另一行数据没有缺失。你可以这样想：一个包（bag）中有多个数，当其中一个为null，而其他不为null时，把它们相加会自动忽略null。<br><br>然而，第三行 (6,) 是不是太刺眼了？没错，因为数据文件 1.txt 的最后一行缺失了第二列，所以，在 SUM(B.x) 中的 B.x 为null就会导致计算结果为null，从而什么也输出不了。<br><br>这就与我们期望的输出有点不同了。我们希望这种缺失的数据不要空着，而是输出0。该怎么做呢？<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="color:#ff0000;">想法1</span>：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>D = FOREACH C GENERATE group, ((IsEmpty(B.x)) ? 0 : SUM(B.x));<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1,4)<br>(5,9)<br>(6,)<br>(8,3)<br></pre></p>
<p></p><p>可见行不通。从这个结果我们知道，IsEmpty(B.x) 为false，即B.x不是empty的，所以不能这样做。<br><br><span style="color:#ff0000;">想法2</span>：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>D = FOREACH C GENERATE group, ((B.x is null) ? 0 : SUM(B.x));<br></pre></p>
<p></p><p>输出结果还是与上面一样！仍然行不通。这更奇怪了：B.x既非empty，也非null，那么它是什么情况？按照我的理解，当group为6时，它应该是一个非空的包（bag），里面有一个null的东西，所以，这个包不是empty的，它也非null。我不知道这样理解是否正确，但是它看上去就像是这样的。<br><br><span style="color:#ff0000;">想法3</span>：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>D = FOREACH C GENERATE group, SUM(B.x) AS s;<br>E = FOREACH D GENERATE group, ((s is null) ? -1 : s);<br>DUMP E;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1,4)<br>(5,9)<br>(6,-1)<br>(8,3)<br></pre></p>
<p></p><p>可见达到了我们想要的结果。这与本文前面部分的做法是一致的，即：先得到含null的结果，再把这个结果中的null替换为指定的值。<br><br>有人会问：就没有办法在生成数据集D的时候，就直接通过判断语句来实现这个效果吗？据我目前所知是不行的，如果哪位读者知道，不妨告知。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（33）</span>DISTINCT操作用于去重，正因为它要把数据集合到一起，才知道哪些数据是重复的，因此，它会产生reduce过程。同时，在map阶段，它也会利用combiner来先去除一部分重复数据以加快处理速度。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（34）</span>如何将Pig job的优先级设为HIGH<br><br>嫌Pig job运行太慢？只需在Pig脚本的开头加上一句：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>set job.priority HIGH;<br></pre></p>
<p></p><p>即可将Pig job的优先级设为高了。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（35）</span>&ldquo;<span style="color:#ff0000;">Scalars can be only used with projections</span>&rdquo;错误的原因<br><br>这个错误提示比较不直观，光看这句话是不容易发现错误所在的，但是，只要你一Google，可能就找到原因了，例如<a href="https://issues.apache.org/jira/browse/PIG-1788" target="_blank">这个链接</a>里的反馈。<br><br>在这里，我也想用一个简单的例子给大家用演示一下产生这个错误的原因之一。<br><br>假设有如下数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]$ cat 1.txt<br>a    1<br>b    8<br>c    3<br>c    3<br>d    6<br>d    3<br>c    5<br>e    7<br></pre></p>
<p></p><p>现在要统计：在第1列的每一种组合下，第二列为3和6的数据分别有多少条？<br><br>例如，当第1列为 c 时，第二列为3的数据有2条，为6的数据有0条；当第1列为d时，第二列为3的数据有1条，为6的数据有1条。其他的依此类推。<br><br>Pig代码如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1:chararray, col2:int);<br>B = GROUP A BY col1;<br>C = FOREACH B {<br>D = FILTER A BY col2 == 3;<br>E = FILTER A BY col2 == 6;<br>GENERATE group, COUNT(D), COUNT(E);<br>};<br>DUMP C;<br></pre></p>
<p></p><p>输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(a,0,0)<br>(b,0,0)<br>(c,2,0)<br>(d,1,1)<br>(e,0,0)<br></pre></p>
<p></p><p>可见结果是正确的。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>那么，如果我在上面的代码中，把&ldquo;D = FILTER <span style="color:#ff0000;">A</span> BY col2 == 3&rdquo;不小心写成了&ldquo;D = FILTER <span style="color:#ff0000;">B</span> BY col2 == 3&rdquo;，就肯定会得到&ldquo;<span style="color:#0000ff;">Scalars can be only used with projections</span>&rdquo;的错误提示。<br><br>说白了，还是要时刻注意你每一步生成的数据的结构，眼睛睁大，千万不要用错了relation。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（36）</span>什么是嵌套的FOREACH/内部的FOREACH<br><br>嵌套的（nested）FOREACH和内部的（inner）FOREACH是一个意思，正如你在本文第(35)条中所见，一个FOREACH可以对每一条记录施以多种不同的关系操作，然后再GENERATE得到想要的结果，这就是嵌套的/内部的FOREACH。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（37）</span>错误&ldquo;Could not infer the matching function for org.apache.pig.builtin.CONCAT&rdquo;的原因之一<br><br>如果你遇到这个错误，那么有可能是你在多级CONCAT嵌套的时候，没有写对语句，例如&ldquo;CONCAT(CONCAT(CONCAT(a, b), c), d)&rdquo;这样的嵌套，由于括号众多，所以写错了是一点也不奇怪的。我遇这个错误的时候，是由于CONCAT太多，自己多写了一个都没有发现。希望我的提醒能给你一点解决问题的提示。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（38）</span>用Pig加载HBase数据时遇到的错误&ldquo;<span style="color:#0000ff;">ERROR 2999: Unexpected internal error. could not instantiate &#39;com.twitter.elephantbird.pig.load.HBaseLoader&#39; with arguments XXX</span>&rdquo;的原因之一<br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color: rgb(0, 0, 255); ">Apache Pig中文教程（进阶）</span></a>》</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（39）</span>错误&ldquo;<span style="color:#0000ff;">ERROR 1039: In alias XX, incompatible types in EqualTo Operator left hand side:XXX right hand side:XXX</span>&rdquo;的原因<br><br>其实这个错误提示太明显了，就是类型不匹配造成的。上面的XXX可以指代不同的类型。<br><br>这说明，前面可能有一个类型为long的字段，后面你却把它当chararray来用了，例如：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: int, col2: long);<br>B = FILTER A BY col2 == &#39;123456789&#39;;<br>C = GROUP B ALL;<br>D = FOREACH C GENERATE COUNT(B);<br>DUMP D;<br></pre></p>
<p></p><p>就会出错：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>ERROR 1039: In alias B, incompatible types in EqualTo Operator left hand side:long right hand side:chararray</p><br><p></p>
<p></p><p>只要把col2强制类型转换一下（或者一开始就将其类型指定为chararray）就可以解决问题。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>不仅在进行数据比较中，在JOIN时也经常出现数据类型不匹配导致的错误问题。我在实际工作中发现，有的同学写了比较长的Pig代码，出现了这样的错误却不会仔细去看错误提示，而是绞尽脑汁地逐句去检查语法（语法是没有错的），结果费了很大的劲才知道是类型问题，得不偿失，还不如仔细看错误提示想想为什么。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（40）</span>在grunt交互模式下，如何在编辑Pig代码的时候跳到行首和行末/行尾<br><br>在grunt模式下，如果你写了一句超长的Pig代码，那么，你想通过HOME/END键跳到行首和行末是做不到的。<br><br>按HOME时，Pig会在你的光标处插入一个&ldquo;1~&rdquo;：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col: int1~);<br></pre></p>
<p></p><p>按END时，Pig会在你的光标处插入一个&ldquo;4~&rdquo;：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col: int4~);<br></pre></p>
<p></p><p>正确的做法是：按Ctrl+A 和 Ctrl+E 代替 HOME 和 END，就可以跳到行首和行末了。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（41）</span>不能对同一个关系（relation）进行JOIN<br><br>假设有如下文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>1    a<br>2    e<br>3    v<br>4    n<br></pre></p>
<p></p><p>我想对第一列这样JOIN：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);<br>B = JOIN A BY col1, A BY col1;<br></pre></p>
<p></p><p>那么当你试图 DUMP B 的时候，会报如下的错：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>ERROR org.apache.pig.tools.grunt.Grunt - ERROR 1108: Duplicate schema alias: A::col1 in &quot;B&quot;</p><br><p></p>
<p></p><p>这是因为Pig会弄不清JOIN之后的字段名&mdash;&mdash;两个字段均为A::col1，使得一个关系（relation）中出现了重复的名字，这是不允许的。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>要解决这个问题，只需将数据LOAD两次，并且给它们起不同的名字就可以了：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; B = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; C = JOIN A BY col1, B BY col1;<br>grunt&gt; DESCRIBE C;<br>C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}<br>grunt&gt; DUMP C;<br>(1,a,1,a)<br>(2,e,2,e)<br>(3,v,3,v)<br>(4,n,4,n)<br></pre></p>
<p></p><p>从上面的 C 的schema，你可以看出来，如果对同一个关系A的第一列进行JOIN，会导致schema中出现相同的字段名，所以当然会出错。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（42）</span>外部的JOIN(outer JOIN)<br><br>初次使用JOIN时，一般人使用的都是所谓的&ldquo;内部的JOIN&rdquo;(inner JOIN)，也即类似于 C = JOIN A BY col1, B BY col2 这样的JOIN。Pig也支持&ldquo;外部的JOIN&rdquo;(outer JOIN)，下面就举一个例子。<br><br>假设有文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 1.txt<br>1    a<br>2    e<br>3    v<br>4    n<br></pre></p>
<p></p><p>以及：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 2.txt<br>9    a<br>2    e<br>3    v<br>0    n<br></pre></p>
<p></p><p>现在来对这两个文件的第一列作一个outer JOIN：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; B = LOAD &#39;2.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; C = JOIN A BY col1 LEFT OUTER, B BY col1;<br>grunt&gt; DESCRIBE C;<br>C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}<br>grunt&gt; DUMP C;<br>(1,a,,)<br>(2,e,2,e)<br>(3,v,3,v)<br>(4,n,,)<br></pre></p>
<p></p><p>在outer JOIN中，&ldquo;OUTER&rdquo;关键字是可以省略的。从上面的结果，我们注意到：如果换成一个inner JOIN，则两个输入文件的第一、第四行都不会出现在结果中（因为它们的第一列不相同），而在LEFT OUTER JOIN中，文件1.txt的第一、四行却被输出了，所以这就是LEFT OUTER JOIN的特点：<span style="color:#800080;">对左边的记录来说，即使<span class="KSFIND_CLASS_SELECT" id="0KSFindDIV">它与右边的记录不匹配，它也会被</span>包含在输出数据中</span>。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>同理可知RIGHT OUTER JOIN的功能&mdash;&mdash;把上面的 LEFT 换成 RIGHT，结果如下：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(,,0,n)<br>(2,e,2,e)<br>(3,v,3,v)<br>(,,9,a)<br></pre></p>
<p></p><p>可见，与左边的记录不匹配的右边的记录被保存了下来，而左边的记录没有保存下来（两个逗号表明其为空），这就是RIGHT OUTER JOIN的效果，与我们想像的一样。<br><br>有人会问，OUTER JOIN在实际中可以用来做什么？举一个例子：可以用来求&ldquo;<span style="color:#a52a2a;">不在某数据集中的那些数据（即：不重合的数据）</span>&rdquo;。还是以上面的两个数据文件为例，现在我要求出 1.txt 中，第一列不在 2.txt 中的第一列的那些记录，肉眼一看就知道，1和4这两个数字在 2.txt 的第一列里没有出现，而2和3出现了，因此，我们要找的记录就是：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>1    a<br>4    n<br></pre></p>
<p></p><p>要实现这个效果，Pig代码及结果为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;1.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; B = LOAD &#39;2.txt&#39; AS (col1: int, col2: chararray);<br>grunt&gt; C = JOIN A BY col1 LEFT OUTER, B BY col1;<br>grunt&gt; DESCRIBE C;<br>C: {A::col1: int,A::col2: chararray,B::col1: int,B::col2: chararray}<br>grunt&gt; D = FILTER C BY (B::col1 is null);<br>grunt&gt; E = FOREACH D GENERATE A::col1 AS col1, A::col2 AS col2;<br>grunt&gt; DUMP E;<br>(1,a)<br>(4,n)<br></pre></p>
<p></p><p>可见，我们确实找出了&ldquo;不重合的记录&rdquo;。在作海量数据分析时，这种功能是极为有用的。<br><br>最后来一个总结：<br><br>假设有两个数据集（在1.txt和2.txt中），分别都只有1列，则如下代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: chararray);<br>B = LOAD &#39;2.txt&#39; AS (col1: chararray);<br>C = JOIN A BY col1 LEFT OUTER, B BY col1;<br>D = FILTER C BY (B::col1 is null);<br>E = FOREACH D GENERATE A::col1 AS col1;<br>DUMP E;<br></pre></p>
<p></p><p>计算结果为：在A中，但不在B中的记录。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（43）</span>JOIN的优化<br><br>请看这个链接：《<a href="http://www.codelast.com/?p=4249" target="_blank"><span style="color: rgb(0, 0, 255); ">Apache Pig中文教程（进阶）</span></a>》</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（44）</span>GROUP时按所有字段分组可以用GROUP ALL吗<br><br>假设你有如下数据文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]# cat 3.txt<br>1    9<br>2    2<br>3    3<br>4    0<br>1    9<br>1    9<br>4    0<br></pre></p>
<p></p><p>现在要找出第1、2列的组合中，每一种的个数分别为多少，例如，(1,9)组合有3个，(4,0)组合有两个，依此类推。<br><br>显而易见，我们只需要用GROUP就可以轻易完成这个任务。于是写出如下代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);<br>B = GROUP A ALL;<br>C = FOREACH B GENERATE group, COUNT(A);<br>DUMP C;<br></pre></p>
<p></p><p>可惜，结果不是我们想要的：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(all,7)<br></pre></p>
<p></p><p>为什么呢？我们的本意是按所有列来GROUP，于是使用了GROUP ALL，但是这实际上变成了统计行数，下面的代码就是一段标准的统计数据行数的代码：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);<br>B = GROUP A ALL;<br>C = FOREACH B GENERATE COUNT(A);<br>DUMP C;<br></pre></p>
<p></p><p>因此，上面的&nbsp;<span style="color:#0000ff;">C = FOREACH B GENERATE group, COUNT(A)</span> 也无非就是多打印了一个group的名字（<span style="color:#ff0000;">all</span>）而已&mdash;&mdash;group的名字被设置为&ldquo;<span style="color:#ff0000;">all</span>&rdquo;，这是Pig帮你做的。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br>正确的做法很简单，只需要按所有字段GROUP，就可以了：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;3.txt&#39; AS (col1: int, col2: int);<br>B = GROUP A BY (col1, col2);<br>C = FOREACH B GENERATE group, COUNT(A);<br>DUMP C;<br></pre></p>
<p></p><p>结果如下：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>((1,9),3)<br>((2,2),1)<br>((3,3),1)<br>((4,0),2)<br></pre></p>
<p></p><p>这与我们前面分析的正确结果是一样的。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（45）</span>在Pig中使用中文字符串<br><br>有读者来信问我，<span style="color:#800080;">如何在Pig中使用中文作为FILTER的条件</span>？我做了如下测试，结论是可以使用中文。<br><br>数据文件 data.txt 内容为（每一列之间以TAB为分隔符）：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>1    北京市    a<br>2    上海市    b<br>3    北京市    c<br>4    北京市    f<br>5    天津市    e<br></pre></p>
<p></p><p>Pig脚本文件 test.pig 内容为：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;data.txt&#39; AS (col1: int, col2: chararray, col3: chararray);<br>B = FILTER A BY (col2 == &#39;北京市&#39;);<br>DUMP B;<br></pre></p>
<p></p><p>首先，我这两个文件的编码都是<span style="color:#ff0000;">UTF-8(无BOM)</span>，在Linux命令行下，我直接以本地模式执行Pig脚本 test.pig：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>pig -x local test.pig<br></pre></p>
<p></p><p>得到的输出结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1,北京市,a)<br>(3,北京市,c)<br>(4,北京市,f)<br></pre></p>
<p></p><p>可见结果是正确的。<br><br><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="color:#0000ff;">但是</span>，如果我在grunt交互模式下，把 test.pig 的内容粘贴进去执行，是得不到任何输出结果的：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>grunt&gt; A = LOAD &#39;data.txt&#39; AS (col1: int, col2: chararray, col3: chararray);<br>grunt&gt; B = FILTER A BY (col2 == &#39;北京市&#39;);<br>grunt&gt; DUMP B;<br></pre></p>
<p></p><p>具体原因我不清楚，但是至少有一点是肯定的：可以使用中文作为FILTER的条件，只要不在交互模式下执行你的Pig脚本即可。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（46）</span>如何统计 tuple 中的 field 数，bag 中的 tuple 数，map 中的 key/value 组数<br><br>一句话：用Pig内建的 <span style="color:#0000ff;">SIZE</span> 函数：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>Computes the number of elements based on any Pig data type.</p><br><p></p>
<p></p><p>具体可看<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html#SIZE" target="_blank">这个</a>链接。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（47）</span>一个字符串为null，与它为空不一定等价<br><br>在某些情况下，要获取&ldquo;不为空&rdquo;的字符串，仅仅用 is not null 来判断是不够的，还应该加上 SIZE(field_name) &gt; 0 的条件：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>B = FILTER A BY (field_name is not null AND (SIZE(field_name) &gt; 0L));<br></pre></p>
<p></p><p>注意，这只是在某些情况下需要这样做，在一般情况下，仅用 is not null 来过滤就可以了。我并没有总结出特殊情况是哪些情况，我只能说我我不是第一次遇到此情况了，所以才有了这一个结论。<br><br>注意上面使用的是&ldquo;0<span style="color:#ff0000;">L</span>&rdquo;，因为SIZE()返回的是long类型，如果不加L，在Pig0.10下会出现一个警告，例如：</p><p></p>
<p><blockquote></blockquote></p>
<p></p><p><br>[main] WARN &nbsp;org.apache.pig.PigServer - Encountered Warning IMPLICIT_CAST_TO_LONG 1 time(s)</p><br><p></p>
<p></p><p><br><span style="background-color:#00ff00;">（48）</span>Pig中的各operator（操作符），哪些会触发reduce过程<br><br><span style="color:#ff0000;">①</span>GROUP：由于GROUP操作会将所有具有相同key的记录收集到一起，所以数据如果正在map中处理的话，就会触发shuffle&rarr;reduce的过程。<br><br><span style="color: rgb(255, 0, 0); ">②</span>ORDER：由于需要将所有相等的记录收集到一起（才能排序），所以ORDER会触发reduce过程。同时，除了你写的那个Pig job之外，Pig还会添加一个额外的M-R job到你的数据流程中，因为Pig需要对你的数据集做采样，以确定数据的分布情况，从而解决数据分布严重不均的情况下job效率过于低下的问题。<br><br><span style="color: rgb(255, 0, 0); ">③</span>DISTINCT：由于需要将记录收集到一起，才能确定它们是不是重复的，因此DISTINCT会触发reduce过程。当然，DISTINCT也会利用combiner在map阶段就把重复的记录移除。<br><br><span style="color: rgb(255, 0, 0); ">④</span>JOIN：JOIN用于求重合，由于求重合的时候，需要将具有相同key的记录收集到一起，因此，JOIN会触发reduce过程。<br><br><span style="color: rgb(255, 0, 0); ">⑤</span>LIMIT：由于需要将记录收集到一起，才能统计出它返回的条数，因此，LIMIT会触发reduce过程。<br><br><span style="color: rgb(255, 0, 0); ">⑥</span>COGROUP：与GROUP类似（参看本文前面的部分），因此它会触发reduce过程。<br></p>
<p><font color="#ff0000">⑦</font>CROSS：计算两个或多个关系的叉积。</p><p></p>
<p></p><p><span style="background-color:#00ff00;">（49）</span>如何统计一个字符串中包含的指定字符数<br><br>这可以不算是个Pig的问题了，你可以把它认为是一个shell的问题。从本文前面部分我们已经知道，Pig中可以用 STREAM … THROUGH 来调用shell进行辅助数据处理，所以在这我们也能这样干。<br><br>假设有文本文件：</p><p></p>
<p><pre class="brush:shell;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>[root@localhost ~]$ cat 1.txt<br>123    abcdef:243789174<br>456    DFJKSDFJ:3646:555558888<br>789    yKDSF:00000%0999:2343324:11111:33333<br></pre></p>
<p></p><p>现在要统计：每一行中，第二列里所包含的冒号（&ldquo;:&rdquo;）分别为多少？代码如下：</p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;1.txt&#39; AS (col1: chararray, col2: chararray);<br>B = STREAM A THROUGH <code>awk -F&amp;quot;:&amp;quot; &amp;#39;{print NF-1}&amp;#39;</code> AS (colon_count: int);<br>DUMP B;<br></pre></p>
<p></p><p>结果为：</p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>(1)<br>(2)<br>(4)<br></pre></p>
<p></p><p><span style="color: rgb(255, 255, 255); ">文章来源：</span><a href="http://www.codelast.com/" target="_blank"><span style="color: rgb(255, 255, 255); ">http://www.codelast.com/</span></a><br><br><span style="background-color:#00ff00;">（50）</span>UDF是区分大小写的<br><br>因为UDF是由Java类来实现的，所以区分大小写，就这么简单。</p><p></p>
<p></p><p><span style="background-color: rgb(0, 255, 0);">（51）</span><span style="font-family: 文泉驿等宽微米黑;">设置Pig job的job name<br><br>在Pig脚本开头加上一句：</span></p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>set job.name &#39;My-Job-Name&#39;;<br></pre></p>
<p></p><p><span style="font-family: 文泉驿等宽微米黑;">那么，执行该Pig脚本之后，在Hadoop的Job Tracker中看到的&ldquo;Name&rdquo;就是&ldquo;My-Job-Name&rdquo;了。<br><br>如果不设置，显示的name是类似于&ldquo;</span>Job6245768625829738970.jar<span style="font-family: 文泉驿等宽微米黑;">&rdquo;这样的东西，job多的时候完全没有标识度，建议一定要设置一个特殊的job name。</span></p><p></p>
<p></p><p><span style="background-color: rgb(0, 255, 0);">（52）</span><span style="font-family: 文泉驿等宽微米黑;">把纯文本转化为JSON<br><br>假设输入文件 a.txt 内容为：</span></p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>1    2<br>9    8<br></pre></p>
<p></p><p><span style="font-family: 文泉驿等宽微米黑;">则如下Pig代码将把它转化为JSON格式：</span></p><p></p>
<p><pre class="brush:sql;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>A = LOAD &#39;a.txt&#39; AS (col1: chararray, col2: chararray);<br>B = STORE A INTO &#39;result&#39; USING JsonStorage();<br></pre></p>
<p></p><p><span style="font-family: 文泉驿等宽微米黑;">查看输出文件的内容是：</span></p><p></p>
<p><pre class="brush:plain;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;"><br>{&quot;col1&quot;:&quot;1&quot;,&quot;col2&quot;:&quot;2&quot;}<br>{&quot;col1&quot;:&quot;9&quot;,&quot;col2&quot;:&quot;8&quot;}<br></pre></p>
<p></p><p><span style="font-family: 文泉驿等宽微米黑;">可见，你LOAD输入数据时定义的字段名，就是输出文件中的JSON字段名。</span></p><p></p>
<p><div id="KSFIND_MASK" style="background-color: rgb(0, 0, 0); opacity: 0.22; position: absolute !important; left: 0px !important; top: 0px !important; border: 0px none !important; padding: 0px !important; z-index: 1000000 !important; height: 0px; width: 0px; display: none; cursor: auto; "><br>&nbsp;</div><br><!--[syntaxhighlighter]--><br><!--代码高亮，请勿编辑--></p>
<script type="text/javascript" src="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shCore.js"></script><script type="text/javascript" src="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushShell.js"></script>
<script type="text/javascript" src="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushSql.js"></script>
<script type="text/javascript" src="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushCSharp.js"></script>
<script type="text/javascript" src="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/scripts/shBrushPlain.js"></script>
<!-- <link type="text/css" rel="stylesheet" href="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shCoreCk.css" /> -->
<!-- <link type="text/css" rel="stylesheet" href="https://www.codelast.com/wp-content/plugins/ck-and-syntaxhighlighter/syntaxhighlighter/styles/shThemeCk.css" /> -->
<link rel="stylesheet" type="text/css" href="//www.codelast.com/wp-content/cache/wpfc-minified/egl898wy/68cop.css" media="all">
<script type="text/javascript">
SyntaxHighlighter.defaults['class-name']    = '';
SyntaxHighlighter.defaults['smart-tabs']    = true;
SyntaxHighlighter.defaults['tab-size']        = 2;
SyntaxHighlighter.defaults['gutter']        = true;
SyntaxHighlighter.defaults['quick-code']    = true;
SyntaxHighlighter.defaults['collapse']         = false;
SyntaxHighlighter.defaults['auto-links']    = true;
SyntaxHighlighter.defaults['toolbar']        = true;
SyntaxHighlighter.all();
</script>

        </div>
        
        
        
    </div>
</div>










</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="Jiang Li">
                    
                    
                    <p class="is-size-4 is-block">
                        Jiang Li
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        BE, USST
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Shanghai, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Artikel
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Kategori
                    </p>
                    <p class="title has-text-weight-normal">
                        0
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tag
                    </p>
                    <p class="title has-text-weight-normal">
                        1
                    </p>
                </div>
            </div>
        </nav>

        
        
    </div>
</div>
    
        
    
        

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Tautan
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/RiverLeeGitHub/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">GitHub</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Kategori
            </h3>
            <ul class="menu-list">
            
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Awan tag
        </h3>
        <a href="/tags/Data-Science/" style="font-size: 10px;">Data Science</a>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Terbaru
        </h3>
        
        <article class="media">
            
            <a href="/2019/03/01/MapReduce和YARN的区别和联系-转/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="MapReduce和YARN的区别和联系[转]">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-03-01T07:26:14.000Z">2019-03-01</time></div>
                    <a href="/2019/03/01/MapReduce和YARN的区别和联系-转/" class="has-link-black-ter is-size-6">MapReduce和YARN的区别和联系[转]</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/02/20/Pig的一些基础概念及用法总结-转/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Pig的一些基础概念及用法总结[转]">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-20T09:22:21.000Z">2019-02-20</time></div>
                    <a href="/2019/02/20/Pig的一些基础概念及用法总结-转/" class="has-link-black-ter is-size-6">Pig的一些基础概念及用法总结[转]</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Arsip
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tag
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Data-Science/">
                        <span class="tag">Data Science</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Terbaru
        </h3>
        
        <article class="media">
            
            <a href="/2019/03/01/MapReduce和YARN的区别和联系-转/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="MapReduce和YARN的区别和联系[转]">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-03-01T07:26:14.000Z">2019-03-01</time></div>
                    <a href="/2019/03/01/MapReduce和YARN的区别和联系-转/" class="has-link-black-ter is-size-6">MapReduce和YARN的区别和联系[转]</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/02/20/Pig的一些基础概念及用法总结-转/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Pig的一些基础概念及用法总结[转]">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-20T09:22:21.000Z">2019-02-20</time></div>
                    <a href="/2019/02/20/Pig的一些基础概念及用法总结-转/" class="has-link-black-ter is-size-6">Pig的一些基础概念及用法总结[转]</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Arsip
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tag
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Data-Science/">
                        <span class="tag">Data Science</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Hexo" height="28">
                
                </a>
                <p class="is-size-7">
                <!--&copy; 2019 John Doe&nbsp;-->
                Theme powered by Hexo & Icarus
                
                </p>
            </div>
            <div class="level-end">
            <!--
	    
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="http://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
	    -->
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Kembali ke atas" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Tulis Sesuatu..">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Artikel',
                PAGES: 'Halaman',
                CATEGORIES: 'Kategori',
                TAGS: 'Tag',
                UNTITLED: 'Tanpa Judul',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>